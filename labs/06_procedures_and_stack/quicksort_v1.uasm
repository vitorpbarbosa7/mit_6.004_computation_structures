////////////////////////////////////////////////////////////////////////////////
// Lab 4
////////////////////////////////////////////////////////////////////////////////

// Include the checkoff program:
.include "checkoff.uasm"

// Leave the following as zero to run ALL the test cases, and get your solution
//   validated if all pass.  If you have trouble with test case N, set it to N
//   to run JUST that test case (for easier debugging):
TestCase:       LONG(0)

// Quicksort-in-place code.  We include the C/Python version here as a comment;
// you can use this as a model for your Beta assembly version:

//def partition(array,left,right):
//    # choose middle element of array as pivot
//    pivotIndex = (left+right) >> 1;
//    pivotValue = array[pivotIndex]
//
//    # swap array[right] and array[pivotIndex]
//    # note that we already store array[pivotIndex] in pivotValue
//    array[pivotIndex] = array[right]
//
//    # elements <= the pivot are moved to the left (smaller indices)
//    storeIndex = left
//    for i in xrange(left,right):  # don't include array[right]
//        temp = array[i]
//        if temp <= pivotValue:
//            array[i] = array[storeIndex]
//            array[storeIndex] = temp
//            storeIndex += 1
//
//    # move pivot to its final place
//    array[right] = array[storeIndex]
//    array[storeIndex] = pivotValue;
//    return storeIndex;

partition:
        PUSH(LP)
        PUSH(BP)
        MOVE(SP, BP)
			
		PUSH(R1) // To load array
		PUSH(R2) // To load left
		PUSH(R3) // To load right
		PUSH(R7) // index not multiplied
		PUSH(R4) // pivotIndex
		PUSH(R7) // address of where pivotIndex should point to
		PUSH(R8) // pivotValue
		PUSH(R9) // i from loop
		PUSH(R10) // result comparison from loop
		
		LD(BP, -12, R1) // array
		LD(BP, -16, R2) // left
		LD(BP, -20, R3) // right
		
		//pivotIndex = (left+right) >>1
		ADD(R2, R3, R7)
		SHRC(R7, 1, R7)
			
		// pivotValue = array[pivotIndex]
		// multiplied index in R4
		SHLC(R7, 2, R4)
		// R7 will be the address
		ADD(R1,R4,R7)
		// finally the pivotValue loaded into the register after all calculations of address were made
		LD(R7,0,R8)
		
		
		MOVE(R2, R9)
loop:	
		
		
		
		
		CMPEQ(R9, R3, R10)
		BEQ(loop, R10)
		

// Fill in your code here...

        MOVE(BP, SP)
        POP(BP)
        POP(LP)
        JMP(LP)


//def quicksort(array, left, right):
//    if left < right:
//        pivotIndex = partition(array,left,right)
//        quicksort(array,left,pivotIndex-1)
//        quicksort(array,pivotIndex+1,right)

// quicksort(ArrayBase, left, right)
quicksort:
        PUSH(LP)
        PUSH(BP)
        MOVE(SP, BP)

// Fill in your code here...

        MOVE(BP, SP)
        POP(BP)
        POP(LP)
        JMP(LP)

// Allocate a stack: SP is initialized by checkoff code.
StackBasePtr:
        LONG(StackArea)

.unprotect

StackArea:
        STORAGE(1000)
